import { mkdir, readFile, rm, stat, writeFile } from 'node:fs/promises'
import path from 'node:path'

import { PDFDocument, StandardFonts, rgb } from 'pdf-lib'

import { prisma } from '@/db'

type AssignmentForArtifact = {
  id: string
  status: 'APPROVED' | 'DISPATCHED' | 'CANCELED'
  assignedRole: 'PRIMARY' | 'CROSS_SELL'
  approvedBy: string
  approvedAt: Date
  dispatchedAt: Date | null
  updatedAt: Date
  lead: {
    id: string
    projectName: string | null
    locationText: string | null
    currentStatus: string
  }
  businessUnit: {
    id: string
    code: string
    name: string
  }
  routingRecommendation: {
    id: string
    role: 'PRIMARY' | 'CROSS_SELL'
    ruleScore: { toString: () => string }
    finalScore: { toString: () => string }
    confidence: { toString: () => string }
    reasonSummary: string
    recommendationSkus: Array<{
      rank: number
      confidence: { toString: () => string }
      rationale: string
      buSku: {
        id: string
        skuCode: string
        skuName: string
        skuCategory: string | null
      }
    }>
  }
}

export type DispatchArtifactPayload = {
  artifactVersion: 1
  generatedAt: string
  generatedBy: string
  assignment: {
    id: string
    status: string
    assignedRole: string
    approvedBy: string
    approvedAt: string
    dispatchedAt: string | null
  }
  lead: {
    id: string
    projectName: string | null
    locationText: string | null
    currentStatus: string
  }
  businessUnit: {
    id: string
    code: string
    name: string
  }
  routingRecommendation: {
    id: string
    role: string
    ruleScore: string
    finalScore: string
    confidence: string
    reasonSummary: string
    skuProposals: Array<{
      buSkuId: string
      skuCode: string
      skuName: string
      skuCategory: string | null
      rank: number
      confidence: string
      rationale: string
    }>
  }
}

export type GeneratedAssignmentArtifact = {
  id: string
  artifactType: 'JSON' | 'PDF'
  storagePath: string
  createdAt: Date
}

function resolveArtifactDirectory(): string {
  const fromEnv = process.env.ARTIFACT_OUTPUT_DIR?.trim()
  if (fromEnv) {
    return path.isAbsolute(fromEnv) ? fromEnv : path.resolve(process.cwd(), fromEnv)
  }

  return path.resolve(process.cwd(), '.data', 'assignment-artifacts')
}

function toIso(value: Date | null): string | null {
  if (!value) {
    return null
  }
  return value.toISOString()
}

function formatScore(value: { toString: () => string }): string {
  const parsed = Number(value.toString())
  if (!Number.isFinite(parsed)) {
    return '0.0000'
  }
  return parsed.toFixed(4)
}

export function buildDispatchArtifactPayload(
  assignment: AssignmentForArtifact,
  generatedBy: string,
): DispatchArtifactPayload {
  return {
    artifactVersion: 1,
    generatedAt: new Date().toISOString(),
    generatedBy,
    assignment: {
      id: assignment.id,
      status: assignment.status,
      assignedRole: assignment.assignedRole,
      approvedBy: assignment.approvedBy,
      approvedAt: assignment.approvedAt.toISOString(),
      dispatchedAt: toIso(assignment.dispatchedAt),
    },
    lead: {
      id: assignment.lead.id,
      projectName: assignment.lead.projectName,
      locationText: assignment.lead.locationText,
      currentStatus: assignment.lead.currentStatus,
    },
    businessUnit: {
      id: assignment.businessUnit.id,
      code: assignment.businessUnit.code,
      name: assignment.businessUnit.name,
    },
    routingRecommendation: {
      id: assignment.routingRecommendation.id,
      role: assignment.routingRecommendation.role,
      ruleScore: formatScore(assignment.routingRecommendation.ruleScore),
      finalScore: formatScore(assignment.routingRecommendation.finalScore),
      confidence: formatScore(assignment.routingRecommendation.confidence),
      reasonSummary: assignment.routingRecommendation.reasonSummary,
      skuProposals: assignment.routingRecommendation.recommendationSkus.map((item) => ({
        buSkuId: item.buSku.id,
        skuCode: item.buSku.skuCode,
        skuName: item.buSku.skuName,
        skuCategory: item.buSku.skuCategory,
        rank: item.rank,
        confidence: formatScore(item.confidence),
        rationale: item.rationale,
      })),
    },
  }
}

function buildPdfLines(payload: DispatchArtifactPayload): string[] {
  const lines: string[] = [
    'Synergy Assignment Dispatch Artifact',
    '',
    `Assignment ID: ${payload.assignment.id}`,
    `Status: ${payload.assignment.status}`,
    `Assigned Role: ${payload.assignment.assignedRole}`,
    `Generated At: ${payload.generatedAt}`,
    `Generated By: ${payload.generatedBy}`,
    '',
    `Lead: ${payload.lead.projectName || 'Untitled'} (${payload.lead.id})`,
    `Location: ${payload.lead.locationText || 'Unknown'}`,
    `Lead Status: ${payload.lead.currentStatus}`,
    '',
    `Business Unit: ${payload.businessUnit.name} (${payload.businessUnit.code})`,
    '',
    `Recommendation Score: ${payload.routingRecommendation.finalScore}`,
    `Confidence: ${payload.routingRecommendation.confidence}`,
    'Reason:',
    payload.routingRecommendation.reasonSummary,
    '',
    'Proposed SKUs:',
  ]

  if (payload.routingRecommendation.skuProposals.length === 0) {
    lines.push('No SKU proposal available.')
    return lines
  }

  for (const sku of payload.routingRecommendation.skuProposals) {
    lines.push(
      `${sku.rank}. ${sku.skuCode} - ${sku.skuName} (${sku.confidence})`,
      `   ${sku.rationale}`,
    )
  }

  return lines
}

function wrapText(input: string, maxLength: number): string[] {
  if (input.length <= maxLength) {
    return [input]
  }

  const words = input.split(/\s+/)
  const lines: string[] = []
  let current = ''

  for (const word of words) {
    const next = current ? `${current} ${word}` : word
    if (next.length > maxLength) {
      if (current) {
        lines.push(current)
      }
      current = word
    } else {
      current = next
    }
  }

  if (current) {
    lines.push(current)
  }

  return lines
}

async function buildDispatchPdf(payload: DispatchArtifactPayload): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create()
  let page = pdfDoc.addPage([595, 842])
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica)
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold)

  let y = 810
  const left = 42
  const lines = buildPdfLines(payload)

  for (const line of lines) {
    const wrapped = wrapText(line, 92)
    for (const wrappedLine of wrapped) {
      const useBold = wrappedLine === 'Synergy Assignment Dispatch Artifact'
      page.drawText(wrappedLine, {
        x: left,
        y,
        size: useBold ? 13 : 10,
        font: useBold ? boldFont : font,
        color: rgb(0.12, 0.12, 0.15),
      })
      y -= useBold ? 18 : 13
      if (y < 60) {
        page = pdfDoc.addPage([595, 842])
        y = 810
      }
    }
  }

  return pdfDoc.save()
}

async function ensureDirectory(directoryPath: string): Promise<void> {
  await mkdir(directoryPath, { recursive: true })
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    const details = await stat(filePath)
    return details.isFile()
  } catch {
    return false
  }
}

async function cleanupPreviousArtifacts(assignmentId: string): Promise<void> {
  const previousArtifacts = await prisma.assignmentArtifact.findMany({
    where: {
      assignmentId,
      artifactType: {
        in: ['JSON', 'PDF'],
      },
    },
    select: {
      id: true,
      storagePath: true,
    },
  })

  if (previousArtifacts.length === 0) {
    return
  }

  for (const artifact of previousArtifacts) {
    const exists = await fileExists(artifact.storagePath)
    if (exists) {
      await rm(artifact.storagePath, { force: true })
    }
  }

  await prisma.assignmentArtifact.deleteMany({
    where: {
      id: {
        in: previousArtifacts.map((item) => item.id),
      },
    },
  })
}

export async function generateDispatchArtifacts(
  assignmentId: string,
  generatedBy: string,
): Promise<GeneratedAssignmentArtifact[]> {
  const assignment = await prisma.assignment.findUnique({
    where: { id: assignmentId },
    include: {
      lead: {
        select: {
          id: true,
          projectName: true,
          locationText: true,
          currentStatus: true,
        },
      },
      businessUnit: {
        select: {
          id: true,
          code: true,
          name: true,
        },
      },
      routingRecommendation: {
        select: {
          id: true,
          role: true,
          ruleScore: true,
          finalScore: true,
          confidence: true,
          reasonSummary: true,
          recommendationSkus: {
            orderBy: { rank: 'asc' },
            include: {
              buSku: {
                select: {
                  id: true,
                  skuCode: true,
                  skuName: true,
                  skuCategory: true,
                },
              },
            },
          },
        },
      },
    },
  })

  if (!assignment) {
    throw new Error('Assignment not found for artifact generation.')
  }

  const payload = buildDispatchArtifactPayload(assignment as AssignmentForArtifact, generatedBy)
  const artifactRootDir = resolveArtifactDirectory()
  const assignmentDir = path.join(artifactRootDir, assignment.id)
  await ensureDirectory(assignmentDir)
  await cleanupPreviousArtifacts(assignment.id)

  const stamp = new Date().toISOString().replace(/[:.]/g, '-')
  const jsonPath = path.join(assignmentDir, `dispatch-${stamp}.json`)
  const pdfPath = path.join(assignmentDir, `dispatch-${stamp}.pdf`)

  await writeFile(jsonPath, JSON.stringify(payload, null, 2), 'utf8')
  const pdfBytes = await buildDispatchPdf(payload)
  await writeFile(pdfPath, Buffer.from(pdfBytes))

  const artifacts = await prisma.$transaction(async (tx) => {
    const createdJson = await tx.assignmentArtifact.create({
      data: {
        assignmentId: assignment.id,
        artifactType: 'JSON',
        storagePath: jsonPath,
      },
    })
    const createdPdf = await tx.assignmentArtifact.create({
      data: {
        assignmentId: assignment.id,
        artifactType: 'PDF',
        storagePath: pdfPath,
      },
    })
    return [createdJson, createdPdf]
  })

  console.info('[assignments.artifacts.generated]', {
    assignmentId,
    generatedBy,
    files: artifacts.map((artifact) => artifact.storagePath),
  })

  return artifacts
}

export async function readArtifactFile(storagePath: string): Promise<Uint8Array> {
  const buffer = await readFile(storagePath)
  return new Uint8Array(buffer)
}
